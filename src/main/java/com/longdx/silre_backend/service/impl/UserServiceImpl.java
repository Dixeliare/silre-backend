package com.longdx.silre_backend.service.impl;

import com.aventrix.jnanoid.jnanoid.NanoIdUtils;
import com.longdx.silre_backend.dto.request.CreateUserRequest;
import com.longdx.silre_backend.dto.response.UserResponse;
import com.longdx.silre_backend.model.User;
import com.longdx.silre_backend.repository.UserRepository;
import com.longdx.silre_backend.service.UserService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Service implementation for User operations
 * 
 * Pattern:
 * - @Service annotation
 * - @Transactional for write operations
 * - Inject repositories and utilities
 * - Handle business logic
 * - Map entities to DTOs
 */
@Service
@Transactional
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public UserResponse createUser(CreateUserRequest request) {
        // Check if email already exists
        if (userRepository.existsByEmail(request.email())) {
            throw new IllegalArgumentException("Email already exists: " + request.email());
        }

        // Generate unique public ID (NanoID) - 12 characters
        // Constraint: @Size(max = 20) in User entity
        // Using 12 characters for good balance between uniqueness and URL-friendliness
        // NanoID default alphabet: URL-safe characters (A-Za-z0-9_-)
        String publicId;
        int maxRetries = 10;
        int retries = 0;
        do {
            // Generate NanoID with custom size: 12 characters
            // randomNanoId(Random, char[], int) - uses default alphabet and secure random
            publicId = NanoIdUtils.randomNanoId(
                NanoIdUtils.DEFAULT_NUMBER_GENERATOR,  // SecureRandom
                NanoIdUtils.DEFAULT_ALPHABET,         // URL-safe alphabet
                12                                     // Size: 12 characters
            );
            retries++;
            if (retries >= maxRetries) {
                throw new IllegalStateException("Failed to generate unique public ID after " + maxRetries + " attempts");
            }
        } while (userRepository.existsByPublicId(publicId));

        // Create new user entity
        User user = new User();
        user.setDisplayName(request.displayName());
        user.setEmail(request.email());
        user.setPasswordHash(passwordEncoder.encode(request.password()));
        user.setPublicId(publicId);
        
        // Set timezone from request context (detected by TimezoneInterceptor)
        // If not detected, will default to UTC (already set in entity)
        java.time.ZoneId detectedTimezone = com.longdx.silre_backend.config.TimezoneContext.getCurrentTimezone();
        if (detectedTimezone != null && !detectedTimezone.equals(java.time.ZoneId.of("UTC"))) {
            user.setTimezone(detectedTimezone.getId());
        }
        // If no timezone detected, user.timezone remains "UTC" (default)
        
        // NOTE: internalId (TSID) will be automatically generated by @TsidGenerator
        // DO NOT set internalId manually - let Hibernate generate it via TsidIdGenerator

        // Save user - Hibernate will automatically:
        // 1. Call TsidIdGenerator.generate() to create TSID
        // 2. Set user.internalId with the generated TSID
        // 3. Insert into database
        User savedUser = userRepository.save(user);

        // Return DTO
        return UserResponse.from(savedUser);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<UserResponse> getUserByPublicId(String publicId) {
        return userRepository.findByPublicId(publicId)
                .map(UserResponse::from);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<User> getUserByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    @Override
    public UserResponse updateProfile(String publicId, String displayName, String bio) {
        User user = userRepository.findByPublicId(publicId)
                .orElseThrow(() -> new IllegalArgumentException("User not found: " + publicId));

        if (displayName != null) {
            user.setDisplayName(displayName);
        }
        if (bio != null) {
            user.setBio(bio);
        }

        User updatedUser = userRepository.save(user);
        return UserResponse.from(updatedUser);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean emailExists(String email) {
        return userRepository.existsByEmail(email);
    }
}



